<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Full-Width Canvas Multi-Block Scrolling Ticker</title>
  <style>
    body {
      margin: 0;
      background: #111;
      overflow-x: hidden;
    }
    canvas {
      display: block;
      width: 100vw;  /* CSS full viewport width */
      height: 50px;
    }
  </style>
</head>
<body>
<canvas id="tickerCanvas" height="50px"></canvas>

<script>
  const canvas = document.getElementById('tickerCanvas');
  const ctx = canvas.getContext('2d');

  const speed = 150; // px per second
  const font = '24px sans-serif';
  const spacing = 50; // space between messages in px

  // Resize canvas to full window width and fix height
  function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = 50;
  }
  window.addEventListener('resize', () => {
    resizeCanvas();
  });
  resizeCanvas();

  class RingBuffer {
    constructor(size) {
      this.size = size;
      this.buffer = new Array(size);
      this.head = 0;
      this.count = 0;
    }
    push(item) {
      this.buffer[this.head] = item;
      this.head = (this.head + 1) % this.size;
      if (this.count < this.size) this.count++;
    }
    pop() {
      if (this.count === 0) return null;
      const tailIndex = (this.head + this.size - this.count) % this.size;
      const item = this.buffer[tailIndex];
      this.buffer[tailIndex] = undefined;
      this.count--;
      return item;
    }
    isEmpty() {
      return this.count === 0;
    }
  }

  const buffer = new RingBuffer(20);
  buffer.push("🚀 Rocket launched successfully!");
  buffer.push("ENVIRO TEST");
  buffer.push("🌦️ Chance of rain today.");
  buffer.push("🎉 Welcome to the new ticker demo.");
  buffer.push("🔥 Breaking News: Major event happening!");

  const activeBlocks = [];

  ctx.font = font;

  function canAddNewBlock() {
    if (activeBlocks.length === 0) return true;
    const lastBlock = activeBlocks[activeBlocks.length - 1];
    return lastBlock.x + lastBlock.width + spacing < canvas.width;
  }

  function addNextBlock() {
    const nextText = buffer.pop();
    if (nextText) {
      const width = ctx.measureText(nextText).width;
      activeBlocks.push({ text: nextText, x: canvas.width, width });
    }
  }

  let lastTimestamp = null;

  function draw(timestamp) {
    if (!lastTimestamp) lastTimestamp = timestamp;
    const dt = (timestamp - lastTimestamp) / 1000;
    lastTimestamp = timestamp;

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = '#111';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.fillStyle = '#fff';
    ctx.font = font;
    ctx.textBaseline = 'middle';

    for (let block of activeBlocks) {
      block.x -= speed * dt;
      ctx.fillText(block.text, block.x, canvas.height / 2);
    }

    while (activeBlocks.length > 0 && activeBlocks[0].x + activeBlocks[0].width < 0) {
      const removed = activeBlocks.shift();
      console.log('Block finished:', removed.text);
      buffer.push(removed.text)
    }

    if (canAddNewBlock()) {
      addNextBlock();
    }

    requestAnimationFrame(draw);
  }


  requestAnimationFrame(draw);
</script>
</body>
</html>
